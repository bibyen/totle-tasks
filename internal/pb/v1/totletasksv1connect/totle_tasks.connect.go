// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: v1/totle_tasks.proto

package totletasksv1connect

import (
	context "context"
	errors "errors"
	http "net/http"
	strings "strings"

	connect "connectrpc.com/connect"
	v1 "github.com/bibyen/totle-tasks/internal/pb/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// GoalServiceName is the fully-qualified name of the GoalService service.
	GoalServiceName = "totle_tasks.v1.GoalService"
	// BingoServiceName is the fully-qualified name of the BingoService service.
	BingoServiceName = "totle_tasks.v1.BingoService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// GoalServiceCreateGoalProcedure is the fully-qualified name of the GoalService's CreateGoal RPC.
	GoalServiceCreateGoalProcedure = "/totle_tasks.v1.GoalService/CreateGoal"
	// GoalServiceGetGoalProcedure is the fully-qualified name of the GoalService's GetGoal RPC.
	GoalServiceGetGoalProcedure = "/totle_tasks.v1.GoalService/GetGoal"
	// GoalServiceListAvailableGoalsProcedure is the fully-qualified name of the GoalService's
	// ListAvailableGoals RPC.
	GoalServiceListAvailableGoalsProcedure = "/totle_tasks.v1.GoalService/ListAvailableGoals"
	// GoalServiceBatchGetGoalsProcedure is the fully-qualified name of the GoalService's BatchGetGoals
	// RPC.
	GoalServiceBatchGetGoalsProcedure = "/totle_tasks.v1.GoalService/BatchGetGoals"
	// GoalServiceUpdateGoalProcedure is the fully-qualified name of the GoalService's UpdateGoal RPC.
	GoalServiceUpdateGoalProcedure = "/totle_tasks.v1.GoalService/UpdateGoal"
	// GoalServiceDeleteGoalProcedure is the fully-qualified name of the GoalService's DeleteGoal RPC.
	GoalServiceDeleteGoalProcedure = "/totle_tasks.v1.GoalService/DeleteGoal"
	// BingoServiceGetBingoCardProcedure is the fully-qualified name of the BingoService's GetBingoCard
	// RPC.
	BingoServiceGetBingoCardProcedure = "/totle_tasks.v1.BingoService/GetBingoCard"
	// BingoServiceUpdateBingoCardProcedure is the fully-qualified name of the BingoService's
	// UpdateBingoCard RPC.
	BingoServiceUpdateBingoCardProcedure = "/totle_tasks.v1.BingoService/UpdateBingoCard"
)

// GoalServiceClient is a client for the totle_tasks.v1.GoalService service.
type GoalServiceClient interface {
	// Creates a new goal for the user's bank.
	CreateGoal(context.Context, *connect.Request[v1.CreateGoalRequest]) (*connect.Response[v1.Goal], error)
	// Retrieves a specific goal by resource name.
	GetGoal(context.Context, *connect.Request[v1.GetGoalRequest]) (*connect.Response[v1.Goal], error)
	// Lists only goals that are NOT currently assigned to any BingoCard.
	// This powers the "Available Tasks" picker in the UI.
	ListAvailableGoals(context.Context, *connect.Request[v1.ListAvailableGoalsRequest]) (*connect.Response[v1.ListAvailableGoalsResponse], error)
	// Retrieves multiple goals in one round-trip.
	// Used by BingoService to hydrate the grid layout.
	BatchGetGoals(context.Context, *connect.Request[v1.BatchGetGoalsRequest]) (*connect.Response[v1.BatchGetGoalsResponse], error)
	// Updates goal details (title, completion, etc.) using a FieldMask.
	UpdateGoal(context.Context, *connect.Request[v1.UpdateGoalRequest]) (*connect.Response[v1.Goal], error)
	// Deletes a goal.
	// Validation: Implementation must reject deletion if goal.is_assigned is true.
	DeleteGoal(context.Context, *connect.Request[v1.DeleteGoalRequest]) (*connect.Response[emptypb.Empty], error)
}

// NewGoalServiceClient constructs a client for the totle_tasks.v1.GoalService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewGoalServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) GoalServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	goalServiceMethods := v1.File_v1_totle_tasks_proto.Services().ByName("GoalService").Methods()
	return &goalServiceClient{
		createGoal: connect.NewClient[v1.CreateGoalRequest, v1.Goal](
			httpClient,
			baseURL+GoalServiceCreateGoalProcedure,
			connect.WithSchema(goalServiceMethods.ByName("CreateGoal")),
			connect.WithClientOptions(opts...),
		),
		getGoal: connect.NewClient[v1.GetGoalRequest, v1.Goal](
			httpClient,
			baseURL+GoalServiceGetGoalProcedure,
			connect.WithSchema(goalServiceMethods.ByName("GetGoal")),
			connect.WithClientOptions(opts...),
		),
		listAvailableGoals: connect.NewClient[v1.ListAvailableGoalsRequest, v1.ListAvailableGoalsResponse](
			httpClient,
			baseURL+GoalServiceListAvailableGoalsProcedure,
			connect.WithSchema(goalServiceMethods.ByName("ListAvailableGoals")),
			connect.WithClientOptions(opts...),
		),
		batchGetGoals: connect.NewClient[v1.BatchGetGoalsRequest, v1.BatchGetGoalsResponse](
			httpClient,
			baseURL+GoalServiceBatchGetGoalsProcedure,
			connect.WithSchema(goalServiceMethods.ByName("BatchGetGoals")),
			connect.WithClientOptions(opts...),
		),
		updateGoal: connect.NewClient[v1.UpdateGoalRequest, v1.Goal](
			httpClient,
			baseURL+GoalServiceUpdateGoalProcedure,
			connect.WithSchema(goalServiceMethods.ByName("UpdateGoal")),
			connect.WithClientOptions(opts...),
		),
		deleteGoal: connect.NewClient[v1.DeleteGoalRequest, emptypb.Empty](
			httpClient,
			baseURL+GoalServiceDeleteGoalProcedure,
			connect.WithSchema(goalServiceMethods.ByName("DeleteGoal")),
			connect.WithClientOptions(opts...),
		),
	}
}

// goalServiceClient implements GoalServiceClient.
type goalServiceClient struct {
	createGoal         *connect.Client[v1.CreateGoalRequest, v1.Goal]
	getGoal            *connect.Client[v1.GetGoalRequest, v1.Goal]
	listAvailableGoals *connect.Client[v1.ListAvailableGoalsRequest, v1.ListAvailableGoalsResponse]
	batchGetGoals      *connect.Client[v1.BatchGetGoalsRequest, v1.BatchGetGoalsResponse]
	updateGoal         *connect.Client[v1.UpdateGoalRequest, v1.Goal]
	deleteGoal         *connect.Client[v1.DeleteGoalRequest, emptypb.Empty]
}

// CreateGoal calls totle_tasks.v1.GoalService.CreateGoal.
func (c *goalServiceClient) CreateGoal(ctx context.Context, req *connect.Request[v1.CreateGoalRequest]) (*connect.Response[v1.Goal], error) {
	return c.createGoal.CallUnary(ctx, req)
}

// GetGoal calls totle_tasks.v1.GoalService.GetGoal.
func (c *goalServiceClient) GetGoal(ctx context.Context, req *connect.Request[v1.GetGoalRequest]) (*connect.Response[v1.Goal], error) {
	return c.getGoal.CallUnary(ctx, req)
}

// ListAvailableGoals calls totle_tasks.v1.GoalService.ListAvailableGoals.
func (c *goalServiceClient) ListAvailableGoals(ctx context.Context, req *connect.Request[v1.ListAvailableGoalsRequest]) (*connect.Response[v1.ListAvailableGoalsResponse], error) {
	return c.listAvailableGoals.CallUnary(ctx, req)
}

// BatchGetGoals calls totle_tasks.v1.GoalService.BatchGetGoals.
func (c *goalServiceClient) BatchGetGoals(ctx context.Context, req *connect.Request[v1.BatchGetGoalsRequest]) (*connect.Response[v1.BatchGetGoalsResponse], error) {
	return c.batchGetGoals.CallUnary(ctx, req)
}

// UpdateGoal calls totle_tasks.v1.GoalService.UpdateGoal.
func (c *goalServiceClient) UpdateGoal(ctx context.Context, req *connect.Request[v1.UpdateGoalRequest]) (*connect.Response[v1.Goal], error) {
	return c.updateGoal.CallUnary(ctx, req)
}

// DeleteGoal calls totle_tasks.v1.GoalService.DeleteGoal.
func (c *goalServiceClient) DeleteGoal(ctx context.Context, req *connect.Request[v1.DeleteGoalRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.deleteGoal.CallUnary(ctx, req)
}

// GoalServiceHandler is an implementation of the totle_tasks.v1.GoalService service.
type GoalServiceHandler interface {
	// Creates a new goal for the user's bank.
	CreateGoal(context.Context, *connect.Request[v1.CreateGoalRequest]) (*connect.Response[v1.Goal], error)
	// Retrieves a specific goal by resource name.
	GetGoal(context.Context, *connect.Request[v1.GetGoalRequest]) (*connect.Response[v1.Goal], error)
	// Lists only goals that are NOT currently assigned to any BingoCard.
	// This powers the "Available Tasks" picker in the UI.
	ListAvailableGoals(context.Context, *connect.Request[v1.ListAvailableGoalsRequest]) (*connect.Response[v1.ListAvailableGoalsResponse], error)
	// Retrieves multiple goals in one round-trip.
	// Used by BingoService to hydrate the grid layout.
	BatchGetGoals(context.Context, *connect.Request[v1.BatchGetGoalsRequest]) (*connect.Response[v1.BatchGetGoalsResponse], error)
	// Updates goal details (title, completion, etc.) using a FieldMask.
	UpdateGoal(context.Context, *connect.Request[v1.UpdateGoalRequest]) (*connect.Response[v1.Goal], error)
	// Deletes a goal.
	// Validation: Implementation must reject deletion if goal.is_assigned is true.
	DeleteGoal(context.Context, *connect.Request[v1.DeleteGoalRequest]) (*connect.Response[emptypb.Empty], error)
}

// NewGoalServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewGoalServiceHandler(svc GoalServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	goalServiceMethods := v1.File_v1_totle_tasks_proto.Services().ByName("GoalService").Methods()
	goalServiceCreateGoalHandler := connect.NewUnaryHandler(
		GoalServiceCreateGoalProcedure,
		svc.CreateGoal,
		connect.WithSchema(goalServiceMethods.ByName("CreateGoal")),
		connect.WithHandlerOptions(opts...),
	)
	goalServiceGetGoalHandler := connect.NewUnaryHandler(
		GoalServiceGetGoalProcedure,
		svc.GetGoal,
		connect.WithSchema(goalServiceMethods.ByName("GetGoal")),
		connect.WithHandlerOptions(opts...),
	)
	goalServiceListAvailableGoalsHandler := connect.NewUnaryHandler(
		GoalServiceListAvailableGoalsProcedure,
		svc.ListAvailableGoals,
		connect.WithSchema(goalServiceMethods.ByName("ListAvailableGoals")),
		connect.WithHandlerOptions(opts...),
	)
	goalServiceBatchGetGoalsHandler := connect.NewUnaryHandler(
		GoalServiceBatchGetGoalsProcedure,
		svc.BatchGetGoals,
		connect.WithSchema(goalServiceMethods.ByName("BatchGetGoals")),
		connect.WithHandlerOptions(opts...),
	)
	goalServiceUpdateGoalHandler := connect.NewUnaryHandler(
		GoalServiceUpdateGoalProcedure,
		svc.UpdateGoal,
		connect.WithSchema(goalServiceMethods.ByName("UpdateGoal")),
		connect.WithHandlerOptions(opts...),
	)
	goalServiceDeleteGoalHandler := connect.NewUnaryHandler(
		GoalServiceDeleteGoalProcedure,
		svc.DeleteGoal,
		connect.WithSchema(goalServiceMethods.ByName("DeleteGoal")),
		connect.WithHandlerOptions(opts...),
	)
	return "/totle_tasks.v1.GoalService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case GoalServiceCreateGoalProcedure:
			goalServiceCreateGoalHandler.ServeHTTP(w, r)
		case GoalServiceGetGoalProcedure:
			goalServiceGetGoalHandler.ServeHTTP(w, r)
		case GoalServiceListAvailableGoalsProcedure:
			goalServiceListAvailableGoalsHandler.ServeHTTP(w, r)
		case GoalServiceBatchGetGoalsProcedure:
			goalServiceBatchGetGoalsHandler.ServeHTTP(w, r)
		case GoalServiceUpdateGoalProcedure:
			goalServiceUpdateGoalHandler.ServeHTTP(w, r)
		case GoalServiceDeleteGoalProcedure:
			goalServiceDeleteGoalHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedGoalServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedGoalServiceHandler struct{}

func (UnimplementedGoalServiceHandler) CreateGoal(context.Context, *connect.Request[v1.CreateGoalRequest]) (*connect.Response[v1.Goal], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.GoalService.CreateGoal is not implemented"))
}

func (UnimplementedGoalServiceHandler) GetGoal(context.Context, *connect.Request[v1.GetGoalRequest]) (*connect.Response[v1.Goal], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.GoalService.GetGoal is not implemented"))
}

func (UnimplementedGoalServiceHandler) ListAvailableGoals(context.Context, *connect.Request[v1.ListAvailableGoalsRequest]) (*connect.Response[v1.ListAvailableGoalsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.GoalService.ListAvailableGoals is not implemented"))
}

func (UnimplementedGoalServiceHandler) BatchGetGoals(context.Context, *connect.Request[v1.BatchGetGoalsRequest]) (*connect.Response[v1.BatchGetGoalsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.GoalService.BatchGetGoals is not implemented"))
}

func (UnimplementedGoalServiceHandler) UpdateGoal(context.Context, *connect.Request[v1.UpdateGoalRequest]) (*connect.Response[v1.Goal], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.GoalService.UpdateGoal is not implemented"))
}

func (UnimplementedGoalServiceHandler) DeleteGoal(context.Context, *connect.Request[v1.DeleteGoalRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.GoalService.DeleteGoal is not implemented"))
}

// BingoServiceClient is a client for the totle_tasks.v1.BingoService service.
type BingoServiceClient interface {
	// Retrieves the card for a specific month (YYYY-MM).
	// Use View.FULL to populate goal_data in the response via BatchGetGoals.
	GetBingoCard(context.Context, *connect.Request[v1.GetBingoCardRequest]) (*connect.Response[v1.BingoCard], error)
	// Updates the grid configuration (assigning/moving goals).
	UpdateBingoCard(context.Context, *connect.Request[v1.UpdateBingoCardRequest]) (*connect.Response[v1.BingoCard], error)
}

// NewBingoServiceClient constructs a client for the totle_tasks.v1.BingoService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewBingoServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) BingoServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	bingoServiceMethods := v1.File_v1_totle_tasks_proto.Services().ByName("BingoService").Methods()
	return &bingoServiceClient{
		getBingoCard: connect.NewClient[v1.GetBingoCardRequest, v1.BingoCard](
			httpClient,
			baseURL+BingoServiceGetBingoCardProcedure,
			connect.WithSchema(bingoServiceMethods.ByName("GetBingoCard")),
			connect.WithClientOptions(opts...),
		),
		updateBingoCard: connect.NewClient[v1.UpdateBingoCardRequest, v1.BingoCard](
			httpClient,
			baseURL+BingoServiceUpdateBingoCardProcedure,
			connect.WithSchema(bingoServiceMethods.ByName("UpdateBingoCard")),
			connect.WithClientOptions(opts...),
		),
	}
}

// bingoServiceClient implements BingoServiceClient.
type bingoServiceClient struct {
	getBingoCard    *connect.Client[v1.GetBingoCardRequest, v1.BingoCard]
	updateBingoCard *connect.Client[v1.UpdateBingoCardRequest, v1.BingoCard]
}

// GetBingoCard calls totle_tasks.v1.BingoService.GetBingoCard.
func (c *bingoServiceClient) GetBingoCard(ctx context.Context, req *connect.Request[v1.GetBingoCardRequest]) (*connect.Response[v1.BingoCard], error) {
	return c.getBingoCard.CallUnary(ctx, req)
}

// UpdateBingoCard calls totle_tasks.v1.BingoService.UpdateBingoCard.
func (c *bingoServiceClient) UpdateBingoCard(ctx context.Context, req *connect.Request[v1.UpdateBingoCardRequest]) (*connect.Response[v1.BingoCard], error) {
	return c.updateBingoCard.CallUnary(ctx, req)
}

// BingoServiceHandler is an implementation of the totle_tasks.v1.BingoService service.
type BingoServiceHandler interface {
	// Retrieves the card for a specific month (YYYY-MM).
	// Use View.FULL to populate goal_data in the response via BatchGetGoals.
	GetBingoCard(context.Context, *connect.Request[v1.GetBingoCardRequest]) (*connect.Response[v1.BingoCard], error)
	// Updates the grid configuration (assigning/moving goals).
	UpdateBingoCard(context.Context, *connect.Request[v1.UpdateBingoCardRequest]) (*connect.Response[v1.BingoCard], error)
}

// NewBingoServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewBingoServiceHandler(svc BingoServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	bingoServiceMethods := v1.File_v1_totle_tasks_proto.Services().ByName("BingoService").Methods()
	bingoServiceGetBingoCardHandler := connect.NewUnaryHandler(
		BingoServiceGetBingoCardProcedure,
		svc.GetBingoCard,
		connect.WithSchema(bingoServiceMethods.ByName("GetBingoCard")),
		connect.WithHandlerOptions(opts...),
	)
	bingoServiceUpdateBingoCardHandler := connect.NewUnaryHandler(
		BingoServiceUpdateBingoCardProcedure,
		svc.UpdateBingoCard,
		connect.WithSchema(bingoServiceMethods.ByName("UpdateBingoCard")),
		connect.WithHandlerOptions(opts...),
	)
	return "/totle_tasks.v1.BingoService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case BingoServiceGetBingoCardProcedure:
			bingoServiceGetBingoCardHandler.ServeHTTP(w, r)
		case BingoServiceUpdateBingoCardProcedure:
			bingoServiceUpdateBingoCardHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedBingoServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedBingoServiceHandler struct{}

func (UnimplementedBingoServiceHandler) GetBingoCard(context.Context, *connect.Request[v1.GetBingoCardRequest]) (*connect.Response[v1.BingoCard], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.BingoService.GetBingoCard is not implemented"))
}

func (UnimplementedBingoServiceHandler) UpdateBingoCard(context.Context, *connect.Request[v1.UpdateBingoCardRequest]) (*connect.Response[v1.BingoCard], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("totle_tasks.v1.BingoService.UpdateBingoCard is not implemented"))
}
